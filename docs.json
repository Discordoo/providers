{"modules":[{"name":"Providers","classes":[],"interfaces":[{"name":"CacheProvider","description":"Represents a cache provider. Custom caching providers must implement it.\nSome implementations may use remote cache, e.g. Redis, so all the methods are async.\nThe cache storage structure is very similar to a regular database.\nWe use keyspace as the key to the \"database\", and CacheStorageKey as the key to the \"table\".\n\nKey spaces contain cache storages.\nCache storages contain the cache itself, for example, guilds, members, roles, etc., in the format key => value.\n\nThere is a cache storage named global. It is used for global operation with all cache storages inside the key space.\nWhen the cache provider receives a request with the `global` storage key,\nit must perform the required operation on all the storages inside the key space.\nBUT, if the provider receives a set request with the `global` storage key,\nthe provider must create a new storage with the `global` key and write the data there.\n\nThe provider must create new cache storage when it receives a set request with a previously unknown cache storage key.\nThe same applies to key spaces.\n\nThe provider must determine which cache storages are empty, and then delete them. The same applies to key spaces.\n\nThe provider must give the cache in the form in which it stores it and not try to serialize it into classes.","see":["https://github.com/Discordoo/discordoo/blob/develop/src/cache/DefaultCacheProvider.ts"],"deprecated":false,"meta":{"line":29,"file":"CacheProvider.ts","path":"cache"},"props":[{"name":"compatible","description":"This property indicates what the cache provider can work with.\n'classes' means that the provider can store javascript classes directly,\nwithout serializing them into objects or anything else.\n\n'json' means that the provider can store information in json.\nThe library will send data to the provider in json format (objects without bigint and circular).\n\n'text' means that the provider can store information in strings.\nThe library will translate classes into json, json into strings and send them to the provider.\n\n'buffer' means that the provider can store information encoded in buffer.\nThe library will translate classes to json, json to buffer and send them to the provider.","optional":false,"type":[[["'classes'"," | "],["'json'"," | "],["'text'"," | "],["'buffer'"]]]},{"name":"sharedCache","description":"All cache providers must has this property,\nwhich indicates whether the provider uses shared cache between several shards.\nWhen `true`, the library will not request the cache from neighboring shards,\nbut will immediately request the cache from the provider. Example:\n\ndeveloper wants check if X emoji exists in the cache on all shards --> library sends request to cache provider -->\ncache provider replies --> library replies to developer\n\nWhen `false`, the library will try to find the cache on the shards specified by the developer. Example:\n\ndeveloper wants check if X emoji exists in the cache on all shards --> library sends request to sharding manager -->\nsharding manager sends request to all shards --> shards request cache from local cache providers -->\nshards are replying --> sharding manager serializes replies -->\nsharding manager sends reply to the shard from which the request came --> library replies to developer","optional":false,"type":[[["boolean"]]]},{"name":"clear","description":"Clear all cache from storage","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",") => "],["Promise","<"],["boolean",">"]]]},{"name":"count","description":"Execute a provided function once for each cache element and count the number of elements for which the function returned true","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["predicate",": ("],["value",": "],["V",", "],["key",": "],["K",", "],["provider",": "],["P",") => "],["boolean"," | "],["Promise","<"],["boolean",">) => "],["Promise","<"],["number",">"]]]},{"name":"counts","description":"Execute a provided functions once for each cache element and count the number of elements for which the functions returned true.\nThe order of responses depends on the order of the passed functions.\nExample:\n```js\ncache.counts('members', '123456789123456789', [ (m) => m.presence.status === 'online', (m) => m.presence.status === 'idle' ])\n// will return [ number, number ]. first number = online members, second = idle members.\n```","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["predicates",": "],["Array","<("],["value",": "],["V",", "],["key",": "],["K",", "],["provider",": "],["P",") => "],["boolean"," | "],["Promise","<"],["boolean",">>) => "],["Promise","<"],["Array","<"],["number",">>"]]]},{"name":"delete","description":"Delete a key from cache","optional":false,"type":[[["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["key",": "],["K"," | "],["Array","<"],["K",">) => "],["Promise","<"],["boolean",">"]]]},{"name":"entries","description":"Extract keys and values from storage","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",") => "],["Promise","<"],["Array","<["],["K",", "],["V","]>>"]]]},{"name":"filter","description":"Execute a provided function once for each cache element and then make array of elements that the function returned true for","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["predicate",": ("],["value",": "],["V",", "],["key",": "],["K",", "],["provider",": "],["P",") => "],["boolean"," | "],["Promise","<"],["boolean",">) => "],["Promise","<"],["Array","<["],["K",", "],["V","]>>"]]]},{"name":"find","description":"Execute a provided function once for each cache element and return element that the function returned true for","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["predicate",": ("],["value",": "],["V",", "],["key",": "],["K",", "],["provider",": "],["P",") => "],["boolean"," | "],["Promise","<"],["boolean",">) => "],["Promise","<"],["undefined"," | "],["V",">"]]]},{"name":"forEach","description":"Execute a provided function once for each cache element","optional":false,"type":[[["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["predicate",": ("],["value",": "],["V",", "],["key",": "],["K",", "],["provider",": "],["P",") => "],["unknown",") => "],["Promise","<"],["void",">"]]]},{"name":"get","description":"Get value from key","optional":false,"type":[[["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["key",": "],["K",") => "],["Promise","<"],["undefined"," | "],["V",">"]]]},{"name":"has","description":"Check if key exists in cache","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["key",": "],["K",") => "],["Promise","<"],["boolean",">"]]]},{"name":"init","description":"The init() function exists to tell the provider when the client is starting.\nIf the provider started incorrectly, it should throw an error and reject the promise.","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["Promise","<"],["unknown",">"]]]},{"name":"keys","description":"Extract keys from storage","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",") => "],["Promise","<"],["Array","<"],["K",">>"]]]},{"name":"map","description":"Creates a new array populated with the results of calling a provided function on every cache element","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["predicate",": ("],["value",": "],["V",", "],["key",": "],["K",", "],["provider",": "],["P",") => "],["R"," | "],["Promise","<"],["R",">) => "],["Promise","<"],["Array","<"],["R",">>"]]]},{"name":"set","description":"Set a key to given value","optional":false,"type":[[["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["key",": "],["K",", "],["value",": "],["V",") => "],["Promise","<"],["CacheProvider",">"]]]},{"name":"size","description":"Get size of cache in storage","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",") => "],["Promise","<"],["number",">"]]]},{"name":"sweep","description":"Execute a provided function once for each cache element and then delete the elements that the function returned true for","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["predicate",": ("],["value",": "],["V",", "],["key",": "],["K",", "],["provider",": "],["P",") => "],["boolean"," | "],["Promise","<"],["boolean",">) => "],["Promise","<"],["void",">"]]]},{"name":"values","description":"Extract values from storage","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",") => "],["Promise","<"],["Array","<"],["V",">>"]]]}]},{"name":"GatewayBotInfo","description":"https://discord.com/developers/docs/topics/gateway#get-gateway-bot","meta":{"line":7,"file":"GatewayBotInfo.ts","path":"gateway"},"props":[{"name":"session_start_limit","description":"Information on the current session start limit","optional":false,"type":[[["{"],["\nmax_concurrency",": "],["number",","],["\nremaining",": "],["number",","],["\nreset_after",": "],["number",","],["\ntotal",": "],["number\n","}"]]]},{"name":"shards","description":"The recommended number of shards to use when connecting","optional":false,"type":[[["number"]]]},{"name":"url","description":"The WSS URL that can be used for connecting to the gateway","optional":false,"type":[[["string"]]]}]},{"name":"GatewayProvider","description":"Represents a gateway provider. Custom gateway providers must implement it.\n1. The gateway provider operates events and connects the bot's shards to Discord.\n\n2. **All events expect custom must eventually pass through the gateway manager**. (GatewayManager.emit())\nIf your provider adds new events, these events should not pass through the GatewayManager.\nGateway manager emits events to the client and manages events overload protection and manages cache.\nIf you use a message broker, you still must send events to the client through the gateway manager (on the recipient's side).\n\n3. **WARNING:**\nYOUR PROVIDER MUST EMIT\n[GUILD_MEMBERS_CHUNK](https://discord.com/developers/docs/topics/gateway#guild-members-chunk-guild-members-chunk-event-fields)\nAND\n[READY](https://discord.com/developers/docs/topics/gateway#ready)\nAND\n[GUILD_CREATE](https://discord.com/developers/docs/topics/gateway#guild-create)\nEVENTS WITH RAW DATA TO THE GATEWAY MANAGER REGARDLESS OF THE SITUATION.\nIF YOU DON'T EMIT GUILD_MEMBERS_CHUNK, THE ClientMembersManager#fetchMany AND ClientMembersManager#fetch\nAND ALL DEPENDENT FUNCTIONS WILL RETURN AN INFINITE PROMISE OR TIMEOUT ERROR.\nIF YOU DON'T EMIT READY AND GUILD_CREATE, THE CLIENT WILL NEVER BE ABLE TO START CORRECTLY.\nIF RUNNING IN SHARDING INSTANCE, THE CLIENT WILL BE CYCLICALLY RESTARTED.\n\n4. Gateway [rate limits](https://discord.com/developers/docs/topics/gateway#rate-limiting) must be handled by the provider itself.","see":["https://github.com/Discordoo/discordoo/blob/develop/src/gateway/DefaultGatewayProvider.ts"],"deprecated":false,"meta":{"line":34,"file":"GatewayProvider.ts","path":"gateway"},"props":[{"name":"connect","description":"Connect to discord's gateway","optional":false,"type":[[["("],["shards",": "],["GatewayShardsInfo",") => "],["Promise","<"],["unknown",">"]]]},{"name":"disconnect","description":"Disconnect from gateway","optional":false,"type":[[["("],["shards",": "],["Array","<"],["number",">) => "],["Promise","<"],["unknown",">"]]]},{"name":"emit","description":"Emit event to the gateway manager or remote host (e.g. rabbitmq), but not to the client directly","optional":false,"type":[[["("],["shardId",": "],["number",", "],["event",": "],["string",", "],["data",": "],["Array","<"],["any",">) => "],["unknown"]]]},{"name":"getGateway","description":"Get gateway bot information","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["Promise","<"],["GatewayBotInfo",">"]]]},{"name":"init","description":"The init() function exists to tell the provider when the client is starting.\nIf the provider started incorrectly, it should throw an error and reject the promise.","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["Promise","<"],["unknown",">"]]]},{"name":"ping","description":"Get the network latency of the shards websocket","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["number"]]]},{"name":"reconnect","description":"Reconnect shard(s)","optional":false,"type":[[["("],["shards",": "],["Array","<"],["number",">) => "],["Promise","<"],["unknown",">"]]]},{"name":"reorganizeShards","description":"Disconnect from gateway, then set new shards configuration and connect","optional":false,"type":[[["("],["shards",": "],["GatewayShardsInfo",") => "],["Promise","<"],["unknown",">"]]]},{"name":"send","description":"Send some data to the gateway","optional":false,"type":[[["("],["data",": "],["GatewaySendPayloadLike",", "],["options",": "],["GatewaySendOptions",") => "],["unknown"]]]},{"name":"waitShardSpawnTurn","description":"Insert the shard in the spawn queue. You can simply use GatewayManager.waitShardSpawnTurn for this (client.internals.gateway)","optional":false,"type":[[["("],["shardId",": "],["number",") => "],["Promise","<"],["unknown",">"]]]}]},{"name":"GatewaySendOptions","description":"GatewayProvider.send() options","meta":{"line":2,"file":"GatewaySendOptions.ts","path":"gateway"},"props":[{"name":"important","description":"Whether this request is important or not. If yes, it must send this request first.","optional":true,"type":[[["undefined"," | "],["boolean"]]]},{"name":"shards","description":"Shards to send data to","optional":true,"type":[[["undefined"," | "],["Array","<"],["number",">"]]]}]},{"name":"GatewayShardsInfo","description":"If the client uses sharding, information about how many shards to serve is received during the execution of client.start().\nTherefore, gateway needs such an option, it will override the existing settings and use them to connect.","meta":{"line":5,"file":"GatewayShardsInfo.ts","path":"gateway"},"props":[{"name":"shards","description":"Gateway shards ids to serve","optional":false,"type":[[["Array","<"],["number",">"]]]},{"name":"totalShards","description":"The number of shards the client has","optional":false,"type":[[["number"]]]}]},{"name":"InternetIpcTransportProvider","description":"**IT IS DANGEROUS TO CREATE YOUR OWN PROVIDERS OF THIS TYPE.\nTHIS PROVIDER HAS ACCESS TO ABSOLUTELY ANY INFORMATION INSIDE THE BOT.\nTHIS PROVIDER IS ABLE TO DO ABSOLUTELY ANYTHING WITH THE BOT.\nREAD THE SECURITY INSTRUCTIONS IN THE DESCRIPTION OF THE [listen()](#method:listen) METHOD.**\nRepresents a internet ipc transport provider. Custom internet ipc transport providers must implement it.\n\n1. Unlike LocalIpcTransportProvider, operates with sharding managers on different machines via the Internet.\n2. The listen() method is called once inside each sharding manager.\n3. We will create ONLY 1 instance of your provider in each sharding manager.\nYour provider must operate multiple connections within a single instance.\n4. Your provider should not take more than 100 milliseconds to send a single packet through an ideal connection (localhost).\n5. **Your provider should handle disconnects.**\nWhen the sharding manager is disconnected, your provider should call the IpcOpCodes.ERROR op code with\nthe IpcEvents.DISCONNECTED event in all the listeners connected to the sharding manager.\nThen your provider should disable these listeners.","meta":{"line":24,"file":"InternetIpcTransportProvider.ts","path":"ipc"},"props":[{"name":"connect","description":"Connect to the specified sharding manager.\n1. Your provider must connect to the address specified in the identification data,\nand also provide the receiving server with information about the user and password, if such is provided.\n2. If the user and password are specified and are not correct,\n**your provider should throw an error with message that starts with \"Authentication failed.\"**.\nMessage will be used for error detection and further processing. **The error message you wrote will be given to the user.**\n3. If the server we are trying to connect to is inactive,\n**your provider should throw an error with message that starts with \"The server is unavailable.\"**.\nMessage will be used for error detection and further processing. **The error message you wrote will be given to the user.**\n4. Your provider must return the negative number of the sharding manager.","optional":false,"type":[[["("],["identity",": "],["IpcShardIdentificationOptions",") => "],["Promise","<"],["number",">"]]]},{"name":"disconnect","description":"Disconnect from the specified sharding manager.\nYour provider should emit event (packet) with IpcOpCodes.DISPATCH op code and IpcEvents.DISCONNECTED as t.","optional":false,"type":[[["("],["identity",": "],["IpcShardIdentificationOptions",") => "],["Promise","<"],["void",">"]]]},{"name":"init","description":"The init() function exists to tell the provider when the client is starting.\nIf the provider started incorrectly, it should throw an error and reject the promise.","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["Promise","<"],["unknown",">"]]]},{"name":"listen","description":"Your provider should create a server.\n1. This server should only accept packets from authorized connections.\n2. Also, your server should handle the processing and authorization of connections.\n3. **It is strongly recommended to use TLS-protected connections.**\n4. Your provider will receive default settings from a user with TLS certificates, if the user specifies them.\nIf the user does not specify them, we strongly recommend encrypting the traffic yourself\nin any way available and not accepting any unencrypted traffic.\n**Unencrypted traffic can lead to the seizure of control over the entire system of sharding managers.**\n5. NEVER ACCEPT CONNECTIONS WITHOUT A USER AND PASSWORD. IF AN ATTEMPT IS MADE TO START THE PROVIDER WITHOUT THIS INFORMATION,\nTHE PROVIDER IS OBLIGED TO THROW AN ERROR AND STOP THE PROCESS.\n6. **DO NOT USE PASSWORDS LESS THAN 16 CHARACTERS LONG.** THROW AN ERROR AND STOP THE PROCESS.\n7. **ALL HACKING ATTEMPTS WILL BE ON YOUR PROVIDER.\nTHERE IS NO WAY WE CAN PROTECT OUR SYSTEM IF A HOLE IS FOUND IN YOUR PROVIDER.**\nYOUR PROVIDER WILL HANDLE THE MANAGEMENT COMMANDS OF THE ENTIRE BOT.\n**IT WILL EVENTUALLY BE POSSIBLE TO PULL THE BOT TOKEN THROUGH YOUR PROVIDER IF YOU DON'T TAKE CARE OF SECURITY.**","optional":false,"type":[[["("],["identity",": "],["IpcShardIdentificationOptions",") => "],["Promise","<"],["void",">"]]]},{"name":"send","description":"Send the package to the specified shard.","optional":false,"type":[[["("],["identity",": "],["IpcShardIdentificationOptions",", "],["packet",": "],["IpcPacketLike",") => "],["void"]]]},{"name":"subscribe","description":"Connect the listener. Each incoming packet must be sent to all signed listeners at the same time.","optional":false,"type":[[["("],["listenerId",": "],["string",", "],["fn",": "],["IpcTransportProviderEventCallback",") => "],["void"]]]},{"name":"unsubscribe","description":"Remove the listener.","optional":false,"type":[[["("],["listenerId",": "],["string",") => "],["void"]]]}]},{"name":"IpcManagerIdentificationOptions","description":"Information about the identification of the sharding manager.\nThis information will be passed to the IPC transport provider when the connect() (or disconnect()) method is called.","meta":{"line":6,"file":"IpcManagerIdentificationOptions.ts","path":"ipc"},"props":[{"name":"host","description":"IP address (v6/v4) or domain name to connect or disconnect from.","optional":false,"type":[[["string"]]]},{"name":"id","description":"This is a unique identifier generated by the library for each sharding manager, including shards.","optional":false,"type":[[["string"]]]},{"name":"password","description":"The password used for a more secure connection.","optional":true,"type":[[["undefined"," | "],["string"]]]},{"name":"port","description":"Port. What else?","optional":false,"type":[[["number"]]]},{"name":"user","description":"The username used for a more secure connection.","optional":true,"type":[[["undefined"," | "],["string"]]]}]},{"name":"IpcPacketLike","description":"Represents what IPC packets look like approximately.","meta":{"line":2,"file":"IpcPacketLike.ts","path":"ipc"},"props":[{"name":"d","description":"Any JSON-serializable data","optional":true,"type":[[["undefined"," | "],["any"]]]},{"name":"op","description":"IPC operating codes. Example: IpcOpCodes.EMERGENCY (0)","optional":false,"type":[[["number"]]]},{"name":"t","description":"The name of the event that carries the package. Example: 'RATE_LIMIT_HIT'","optional":true,"type":[[["undefined"," | "],["string"]]]}]},{"name":"IpcShardIdentificationOptions","description":"This information will be passed to the IPC transport provider when the connect() (or disconnect()) method is called.","meta":{"line":6,"file":"IpcShardIdentificationOptions.ts","path":"ipc"},"props":[{"name":"id","description":"This is a unique identifier generated by the library for each shard, including sharding managers.","optional":false,"type":[[["string"]]]},{"name":"process","description":"This property may be nullable only when the shard tries to connect (or disconnect)\nto the sharding manager.","optional":true,"type":[[["undefined"," | "],["Worker"," | "],["Worker"," | "],["ChildProcess"]]]}]},{"name":"LocalIpcTransportProvider","description":"Represents a local ipc transport provider. Custom local ipc transport providers must implement it.\n1. Unlike InternetIpcTransportProvider, operates inside a single machine.\n\n2. The listen() method is called inside each shard. Also, this method is called exactly 1 time in each sharding manager.\n\n3. We will create ONLY 1 instance of your provider in each sharding manager, as well as in each shard.\nYour provider must operate multiple connections within a single instance.\n\n4. Your provider should not take more than 10 milliseconds to send a single packet.\n\n5. **Your provider should handle outages automatically.**\nWhen the shard is disconnected, your provider should call the IpcOpCodes.ERROR op code with the IpcEvents.DISCONNECTED event in all\nthe listeners connected to the shard. Then your provider should disable these listeners.","meta":{"line":22,"file":"LocalIpcTransportProvider.ts","path":"ipc"},"props":[{"name":"connect","description":"Connect to the specified shard. This implies the creation of a stable, preferably encrypted connection with the shard.","optional":false,"type":[[["("],["shard",": "],["number",", "],["identity",": "],["IpcShardIdentificationOptions",") => "],["Promise","<"],["void",">"]]]},{"name":"disconnect","description":"Disconnect from a specific shard. This implies that it is impossible to send packets to this shard (from this client, not others).","optional":false,"type":[[["("],["shard",": "],["number",", "],["identity",": "],["IpcShardIdentificationOptions",") => "],["Promise","<"],["void",">"]]]},{"name":"init","description":"The init() function exists to tell the provider when the client is starting.\nIf the provider started incorrectly, it should throw an error and reject the promise.","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["Promise","<"],["unknown",">"]]]},{"name":"listen","description":"Start the listening server.\nThe server must accept packets intended for the shard whose ID is specified in the first parameter of the function.","optional":false,"type":[[["("],["shard",": "],["number",", "],["id",": "],["string",") => "],["Promise","<"],["void",">"]]]},{"name":"send","description":"Send the package to the specified shard.","optional":false,"type":[[["("],["shard",": "],["number",", "],["packet",": "],["IpcPacketLike",") => "],["void"]]]},{"name":"subscribe","description":"Connect the listener. Each incoming packet must be sent to all signed listeners at the same time.","optional":false,"type":[[["("],["listenerId",": "],["string",", "],["fn",": "],["IpcTransportProviderEventCallback",") => "],["void"]]]},{"name":"unsubscribe","description":"Remove the listener.","optional":false,"type":[[["("],["listenerId",": "],["string",") => "],["void"]]]}]},{"name":"Provider","description":"Base interface for all providers","meta":{"line":2,"file":"Provider.ts","path":"."},"props":[{"name":"init","description":"The init() function exists to tell the provider when the client is starting.\nIf the provider started incorrectly, it should throw an error and reject the promise.","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["Promise","<"],["unknown",">"]]]}]},{"name":"RawAttachment","meta":{"line":1,"file":"RawAttachment.ts","path":"rest"},"props":[{"name":"data","description":"Attachment binary data","optional":false,"type":[[["ArrayBuffer"," | "],["Buffer"]]]},{"name":"name","description":"Attachment filename","optional":false,"type":[[["string"]]]}]},{"name":"RestFailedResponse","description":"Rest provider must return this when request execution failed.","meta":{"line":4,"file":"RestFailedResponse.ts","path":"rest"},"props":[{"name":"headers","description":"Response headers","optional":false,"type":[[["any"]]]},{"name":"latency","description":"The delay between sending the request and the first bit of the response","optional":false,"type":[[["number"]]]},{"name":"result","optional":false,"type":[[["any"]]]},{"name":"statusCode","description":"Response status code or -1 to indicate an internal error of the provider","optional":false,"type":[[["number"]]]},{"name":"success","description":"Whether request executed successfully or not","optional":false,"type":[[["false"]]]}]},{"name":"RestProvider","description":"Represents a rest provider. Custom rest providers must implement it.\n1. **Must not throw any errors**. Use RestFailedResponse instead.\n\n2. Optionally can handle rate limits. Built-in rate limits handling can be disabled in the rest options.","see":["https://github.com/Discordoo/discordoo/blob/develop/src/rest/DefaultRestProvider.ts"],"deprecated":false,"meta":{"line":15,"file":"RestProvider.ts","path":"rest"},"props":[{"name":"init","description":"The init() function exists to tell the provider when the client is starting.\nIf the provider started incorrectly, it should throw an error and reject the promise.","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["Promise","<"],["unknown",">"]]]},{"name":"request","description":"Perform a request","optional":false,"type":[[["("],["data",": "],["RestRequestData",", "],["options",": "],["RestRequestOptions",") => "],["RestFinishedResponse","<"],["T",">"]]]}]},{"name":"RestRequestData","description":"Data for the rest request","meta":{"line":5,"file":"RestRequestData.ts","path":"rest"},"props":[{"name":"attachments","description":"Files to attach (empty array if 0)","optional":false,"type":[[["Array","<"],["RawAttachment",">"]]]},{"name":"body","description":"Request body","optional":true,"type":[[["undefined"," | "],["Record","<"],["any",", "],["any",">"]]]},{"name":"headers","description":"Request headers","optional":true,"type":[[["undefined"," | "],["Record","<"],["string",", "],["any",">"]]]},{"name":"method","description":"GET, POST, etc.","optional":false,"type":[[["RestRequestMethods"]]]},{"name":"path","description":"Url path: https://www.youtube.com/ **watch?v=g0WmiI2QUw0**","optional":false,"type":[[["string"]]]}]},{"name":"RestRequestOptions","description":"Options for the rest request","meta":{"line":4,"file":"RestRequestOptions.ts","path":"rest"},"props":[{"name":"auth","description":"Auth to use for this request","optional":true,"type":[[["undefined"," | "],["AuthLike"]]]},{"name":"reason","description":"Reason for X-Audit-Log-Reason header","optional":true,"type":[[["undefined"," | "],["string"]]]},{"name":"useAuth","description":"Whether use any auth for request or not","optional":true,"type":[[["undefined"," | "],["boolean"]]]}]},{"name":"RestResponse","description":"Base for all rest provider responses","meta":{"line":2,"file":"RestResponse.ts","path":"rest"},"props":[{"name":"headers","description":"Response headers","optional":false,"type":[[["any"]]]},{"name":"latency","description":"The delay between sending the request and the first bit of the response","optional":false,"type":[[["number"]]]},{"name":"statusCode","description":"Response status code or -1 to indicate an internal error of the provider","optional":false,"type":[[["number"]]]},{"name":"success","description":"Whether request executed successfully or not","optional":false,"type":[[["boolean"]]]}]},{"name":"RestSuccessfulResponse","description":"Rest provider must return this when request executed successfully.","meta":{"line":4,"file":"RestSuccessfulResponse.ts","path":"rest"},"props":[{"name":"headers","description":"Response headers","optional":false,"type":[[["any"]]]},{"name":"latency","description":"The delay between sending the request and the first bit of the response","optional":false,"type":[[["number"]]]},{"name":"result","description":"Request result (json body)","optional":false,"type":[[["Body"]]]},{"name":"statusCode","description":"Response status code or -1 to indicate an internal error of the provider","optional":false,"type":[[["number"]]]},{"name":"success","description":"Whether request executed successfully or not","optional":false,"type":[[["true"]]]}]}],"types":[{"name":"AuthLike","type":[[["`"],["Bot"," "],["string","` | `"],["Bearer"," "],["string","`"]]],"meta":{"line":1,"file":"AuthLike.ts","path":"rest"}},{"name":"CacheStorageKey","description":"Cache storages have their own names, called CacheStorageKey.\nThe name \"global\" means that the operation occurs with all cache storages that are located in the specified keyspace.","type":[[["string"," | "],["'global'"]]],"meta":{"line":5,"file":"CacheStorageKey.ts","path":"cache"}},{"name":"GatewaySendPayloadLike","type":[[["{"],["\nd",": "],["any",","],["\nop",": "],["GatewayOpCodes\n","}"]]],"meta":{"line":3,"file":"GatewaySendPayloadLike.ts","path":"gateway"},"props":[{"name":"d","optional":true,"type":[[["undefined"," | "],["any"]]]},{"name":"op","optional":false,"type":[[["GatewayOpCodes"]]]}]},{"name":"IpcTransportProviderEventCallback","description":"Callback for IPC events listeners.","type":[[["("],["from",": "],["number",", "],["packet",": "],["IpcPacketLike",") => "],["any"]]],"meta":{"line":9,"file":"IpcTransportProviderEventCallback.ts","path":"ipc"},"params":[{"name":"from","description":"shard or sharding manager number where the package came from.","optional":false,"type":[[["number"]]]},{"name":"packet","description":"packet data.","optional":false,"type":[[["IpcPacketLike"]]]}],"returns":[[["any"]]]},{"name":"RestFinishedResponse","description":"Just type alias because we don't like use ctrl+c and ctrl+v","type":[[["Promise","<"],["RestSuccessfulResponse","<"],["T","> | "],["RestFailedResponse",">"]]],"meta":{"line":7,"file":"RestFinishedResponse.ts","path":"rest"}}],"enums":[{"name":"GatewayOpCodes","meta":{"line":1,"file":"GatewayOpCodes.ts","path":"gateway"},"props":[{"name":"DISPATCH","type":[[["0"]]]},{"name":"HEARTBEAT","type":[[["1"]]]},{"name":"HEARTBEAT_ACK","type":[[["11"]]]},{"name":"HELLO","type":[[["10"]]]},{"name":"IDENTIFY","type":[[["2"]]]},{"name":"INVALID_SESSION","type":[[["9"]]]},{"name":"RECONNECT","type":[[["7"]]]},{"name":"REQUEST_GUILD_MEMBERS","type":[[["8"]]]},{"name":"RESUME","type":[[["6"]]]},{"name":"STATUS_UPDATE","type":[[["3"]]]},{"name":"VOICE_GUILD_PING","type":[[["5"]]]},{"name":"VOICE_STATE_UPDATE","type":[[["4"]]]}]},{"name":"IpcEvents","description":"Inter-process communication events (t)","meta":{"line":2,"file":"IpcEvents.ts","path":"ipc"},"props":[{"name":"BROADCAST_EVAL","description":"Eval script in specified shards","type":[[["\"BROADCAST_EVAL\""]]]},{"name":"CONNECTED","description":"Emitted when ShardingInstance connected to Discord","type":[[["\"CONNECTED\""]]]},{"name":"DESTROYING","description":"Stop all shards and exit","type":[[["\"DESTROYING\""]]]},{"name":"DISCONNECTED","description":"Shard or sharding manager disconnected from the current client.","type":[[["\"DISCONNECTED\""]]]},{"name":"GUILD_MEMBERS_REQUEST","description":"Request guild members in guild from another shard / Request response (guild members array/error)","type":[[["\"GUILD_MEMBERS_REQUEST\""]]]},{"name":"MESSAGE","description":"Any messages between IPC Server and IPC Client","type":[[["\"MESSAGE\""]]]},{"name":"PARTIAL_RESTARTING","description":"Restart specified shards","type":[[["\"PARTIAL_RESTARTING\""]]]},{"name":"PRESENCE_UPDATE","description":"Update presence in specified shards","type":[[["\"PRESENCE_UPDATE\""]]]},{"name":"RESTARTING","description":"Restart all shards","type":[[["\"RESTARTING\""]]]},{"name":"RESTRUCTURING","description":"Set new shards configuration & restart (across machines only)","type":[[["\"RESTRUCTURING\""]]]},{"name":"REST_LIMITS_SYNC","description":"Rest rate limits synchronization request/response","type":[[["\"REST_LIMITS_SYNC\""]]]}]},{"name":"IpcOpCodes","description":"Operation Codes used in inter-process communication messages","meta":{"line":2,"file":"IpcOpCodes.ts","path":"ipc"},"props":[{"name":"CACHE_OPERATE","description":"Used to cache operating across shards","type":[[["3"]]]},{"name":"DISPATCH","description":"Includes common event (t)","type":[[["0"]]]},{"name":"EMERGENCY","description":"Something urgent is happening. We need to react now.","type":[[["5"]]]},{"name":"ERROR","description":"Looks like something went wrong","type":[[["4"]]]},{"name":"HELLO","description":"IPC Client sends this to IPC Server to explain to him who he is. Contains shards list, heartbeat interval","type":[[["2"]]]},{"name":"IDENTIFY","description":"IPC Server should send this to identify itself in IPC Client","type":[[["1"]]]},{"name":"INVALID_SESSION","description":"Reserved for future.","type":[[["6"]]]}]},{"name":"RestRequestMethods","meta":{"line":1,"file":"RestRequestMethods.ts","path":"rest"},"props":[{"name":"DELETE","type":[[["\"DELETE\""]]]},{"name":"GET","type":[[["\"GET\""]]]},{"name":"PATCH","type":[[["\"PATCH\""]]]},{"name":"POST","type":[[["\"POST\""]]]},{"name":"PUT","type":[[["\"PUT\""]]]}]}],"functions":[],"variables":[]}],"time":1652107701488,"generator":"@discordoo/tapok 2.0.19"}