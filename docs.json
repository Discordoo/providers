{"modules":[{"name":"Providers","classes":[],"interfaces":[{"name":"CacheProvider","description":"Represents a cache provider. Custom caching providers must implement it.\nSome implementations may use remote cache, e.g. Redis, so all the methods are async.\nThe cache storage structure is very similar to a regular database.\nWe use keyspace as the key to the \"database\", and CacheStorageKey as the key to the \"table\".\n\nKey spaces contain cache storages.\nCache storages contain the cache itself, for example, guilds, members, roles, etc., in the format key => value.\n\nThere is a cache storage named global. It is used for global operation with all cache storages inside the key space.\nWhen the cache provider receives a request with the `global` storage key,\nit must perform the required operation on all the storages inside the key space.\nBUT, if the provider receives a set request with the `global` storage key,\nthe provider must create a new storage with the `global` key and write the data there.\n\nThe provider must create new cache storage when it receives a set request with a previously unknown cache storage key.\nThe same applies to key spaces.\n\nThe provider must determine which cache storages are empty, and then delete them. The same applies to key spaces.\n\nThe provider must give the cache in the form in which it stores it and not try to serialize it into classes.","see":["https://github.com/Discordoo/discordoo/blob/develop/src/cache/DefaultCacheProvider.ts"],"deprecated":false,"meta":{"line":29,"file":"CacheProvider.ts","path":"cache"},"props":[{"name":"compatible","description":"This property indicates what the cache provider can work with.\n'classes' means that the provider can store javascript classes directly,\nwithout serializing them into objects or anything else.\n\n'json' means that the provider can store information in json.\nThe library will send data to the provider in json format (objects without bigint and circular).\n\n'text' means that the provider can store information in strings.\nThe library will translate classes into json, json into strings and send them to the provider.\n\n'buffer' means that the provider can store information encoded in buffer.\nThe library will translate classes to json, json to buffer and send them to the provider.","optional":false,"type":[[["'classes'"," | "],["'json'"," | "],["'text'"," | "],["'buffer'"]]]},{"name":"sharedCache","description":"All cache providers must has this property,\nwhich indicates whether the provider uses shared cache between several shards.\nWhen `true`, the library will not request the cache from neighboring shards,\nbut will immediately request the cache from the provider. Example:\n\ndeveloper wants check if X emoji exists in the cache on all shards --> library sends request to cache provider -->\ncache provider replies --> library replies to developer\n\nWhen `false`, the library will try to find the cache on the shards specified by the developer. Example:\n\ndeveloper wants check if X emoji exists in the cache on all shards --> library sends request to sharding manager -->\nsharding manager sends request to all shards --> shards request cache from local cache providers -->\nshards are replying --> sharding manager serializes replies -->\nsharding manager sends reply to the shard from which the request came --> library replies to developer","optional":false,"type":[[["boolean"]]]},{"name":"clear","description":"Clear all cache from storage","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",") => "],["Promise","<"],["boolean",">"]]]},{"name":"count","description":"Execute a provided function once for each cache element and count the number of elements for which the function returned true","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["predicate",": ("],["value",": "],["V",", "],["key",": "],["K",", "],["provider",": "],["P",") => "],["boolean"," | "],["Promise","<"],["boolean",">) => "],["Promise","<"],["number",">"]]]},{"name":"counts","description":"Execute a provided functions once for each cache element and count the number of elements for which the functions returned true.\nThe order of responses depends on the order of the passed functions.\nExample:\n```js\ncache.counts('members', '123456789123456789', [ (m) => m.presence.status === 'online', (m) => m.presence.status === 'idle' ])\n// will return [ number, number ]. first number = online members, second = idle members.\n```","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["predicates",": "],["Array","<("],["value",": "],["V",", "],["key",": "],["K",", "],["provider",": "],["P",") => "],["boolean"," | "],["Promise","<"],["boolean",">>) => "],["Promise","<"],["Array","<"],["number",">>"]]]},{"name":"delete","description":"Delete a key from cache","optional":false,"type":[[["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["key",": "],["K"," | "],["Array","<"],["K",">) => "],["Promise","<"],["boolean",">"]]]},{"name":"entries","description":"Extract keys and values from storage","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",") => "],["Promise","<"],["Array","<["],["K",", "],["V","]>>"]]]},{"name":"filter","description":"Execute a provided function once for each cache element and then make array of elements that the function returned true for","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["predicate",": ("],["value",": "],["V",", "],["key",": "],["K",", "],["provider",": "],["P",") => "],["boolean"," | "],["Promise","<"],["boolean",">) => "],["Promise","<"],["Array","<["],["K",", "],["V","]>>"]]]},{"name":"find","description":"Execute a provided function once for each cache element and return element that the function returned true for","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["predicate",": ("],["value",": "],["V",", "],["key",": "],["K",", "],["provider",": "],["P",") => "],["boolean"," | "],["Promise","<"],["boolean",">) => "],["Promise","<"],["undefined"," | "],["V",">"]]]},{"name":"forEach","description":"Execute a provided function once for each cache element","optional":false,"type":[[["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["predicate",": ("],["value",": "],["V",", "],["key",": "],["K",", "],["provider",": "],["P",") => "],["unknown",") => "],["Promise","<"],["void",">"]]]},{"name":"get","description":"Get value from key","optional":false,"type":[[["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["key",": "],["K",") => "],["Promise","<"],["undefined"," | "],["V",">"]]]},{"name":"has","description":"Check if key exists in cache","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["key",": "],["K",") => "],["Promise","<"],["boolean",">"]]]},{"name":"init","description":"The init() function exists to tell the provider when the client connects to Discord.\nIf the provider started incorrectly, it should throw an error and reject the promise.","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["Promise","<"],["unknown",">"]]]},{"name":"keys","description":"Extract keys from storage","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",") => "],["Promise","<"],["Array","<"],["K",">>"]]]},{"name":"map","description":"Creates a new array populated with the results of calling a provided function on every cache element","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["predicate",": ("],["value",": "],["V",", "],["key",": "],["K",", "],["provider",": "],["P",") => "],["R"," | "],["Promise","<"],["R",">) => "],["Promise","<"],["Array","<"],["R",">>"]]]},{"name":"set","description":"Set a key to given value","optional":false,"type":[[["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["key",": "],["K",", "],["value",": "],["V",") => "],["Promise","<"],["CacheProvider",">"]]]},{"name":"size","description":"Get size of cache in storage","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",") => "],["Promise","<"],["number",">"]]]},{"name":"sweep","description":"Execute a provided function once for each cache element and then delete the elements that the function returned true for","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",", "],["predicate",": ("],["value",": "],["V",", "],["key",": "],["K",", "],["provider",": "],["P",") => "],["boolean"," | "],["Promise","<"],["boolean",">) => "],["Promise","<"],["void",">"]]]},{"name":"values","description":"Extract values from storage","optional":true,"type":[[["undefined"," | "],["("],["keyspace",": "],["string",", "],["storage",": "],["string",") => "],["Promise","<"],["Array","<"],["V",">>"]]]}]},{"name":"GatewayBotInfo","description":"https://discord.com/developers/docs/topics/gateway#get-gateway-bot","meta":{"line":7,"file":"GatewayBotInfo.ts","path":"gateway"},"props":[{"name":"session_start_limit","description":"Information on the current session start limit","optional":false,"type":[[["{"],["\nmax_concurrency",": "],["number",","],["\nremaining",": "],["number",","],["\nreset_after",": "],["number",","],["\ntotal",": "],["number\n","}"]]]},{"name":"shards","description":"The recommended number of shards to use when connecting","optional":false,"type":[[["number"]]]},{"name":"url","description":"The WSS URL that can be used for connecting to the gateway","optional":false,"type":[[["string"]]]}]},{"name":"GatewayProvider","description":"Represents a gateway provider. Custom gateway providers must implement it.\nThe gateway provider operates events and connects the bot's shards to Discord.\n\n**All events expect custom must eventually pass through the gateway manager**. (GatewayManager.emit())\nIf your provider adds new events, these events should not pass through the GatewayManager.\nGateway manager emits events to the client and manages events overload protection and manages cache.\nIf you use a message broker, you still must send events to the client through the gateway manager (on the recipient's side).\n\n**WARNING:**\nYOUR PROVIDER MUST EMIT\n[GUILD_MEMBERS_CHUNK](https://discord.com/developers/docs/topics/gateway#guild-members-chunk-guild-members-chunk-event-fields)\nAND\n[READY](https://discord.com/developers/docs/topics/gateway#ready)\nAND\n[GUILD_CREATE](https://discord.com/developers/docs/topics/gateway#guild-create)\nEVENTS WITH RAW DATA TO THE GATEWAY MANAGER REGARDLESS OF THE SITUATION.\nIF YOU DON'T EMIT GUILD_MEMBERS_CHUNK, THE ClientMembersManager#fetchMany AND ClientMembersManager#fetch\nAND ALL DEPENDENT FUNCTIONS WILL RETURN AN INFINITE PROMISE OR TIMEOUT ERROR.\nIF YOU DON'T EMIT READY AND GUILD_CREATE, THE CLIENT WILL NEVER BE ABLE TO START CORRECTLY.\nIF RUNNING IN SHARDING INSTANCE, THE CLIENT WILL BE CYCLICALLY RESTARTED.\n\nGateway [rate limits](https://discord.com/developers/docs/topics/gateway#rate-limiting) must be handled by the provider itself.","see":["https://github.com/Discordoo/discordoo/blob/develop/src/gateway/DefaultGatewayProvider.ts"],"deprecated":false,"meta":{"line":34,"file":"GatewayProvider.ts","path":"gateway"},"props":[{"name":"connect","description":"Connect to discord's gateway","optional":false,"type":[[["("],["shards",": "],["GatewayShardsInfo",") => "],["Promise","<"],["unknown",">"]]]},{"name":"disconnect","description":"Disconnect from gateway","optional":false,"type":[[["("],["shards",": "],["Array","<"],["number",">) => "],["Promise","<"],["unknown",">"]]]},{"name":"emit","description":"Emit event to the gateway manager or remote host (e.g. rabbitmq), but not to the client directly","optional":false,"type":[[["("],["shardId",": "],["number",", "],["event",": "],["string",", "],["data",": "],["Array","<"],["any",">) => "],["unknown"]]]},{"name":"getGateway","description":"Get gateway bot information","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["Promise","<"],["GatewayBotInfo",">"]]]},{"name":"init","description":"The init() function exists to tell the provider when the client connects to Discord.\nIf the provider started incorrectly, it should throw an error and reject the promise.","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["Promise","<"],["unknown",">"]]]},{"name":"ping","description":"Get the network latency of the shards websocket","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["number"]]]},{"name":"reconnect","description":"Reconnect shard(s)","optional":false,"type":[[["("],["shards",": "],["Array","<"],["number",">) => "],["Promise","<"],["unknown",">"]]]},{"name":"reorganizeShards","description":"Disconnect from gateway, then set new shards configuration and connect","optional":false,"type":[[["("],["shards",": "],["GatewayShardsInfo",") => "],["Promise","<"],["unknown",">"]]]},{"name":"send","description":"Send some data to the gateway","optional":false,"type":[[["("],["data",": "],["GatewaySendPayloadLike",", "],["options",": "],["GatewaySendOptions",") => "],["unknown"]]]},{"name":"waitShardSpawnTurn","description":"Insert the shard in the spawn queue. You can simply use GatewayManager.waitShardSpawnTurn for this (client.internals.gateway)","optional":false,"type":[[["("],["shardId",": "],["number",") => "],["Promise","<"],["unknown",">"]]]}]},{"name":"GatewaySendOptions","description":"GatewayProvider.send() options","meta":{"line":2,"file":"GatewaySendOptions.ts","path":"gateway"},"props":[{"name":"important","description":"Whether this request is important or not. If yes, it must send this request first.","optional":true,"type":[[["undefined"," | "],["boolean"]]]},{"name":"shards","description":"Shards to send data to","optional":true,"type":[[["undefined"," | "],["Array","<"],["number",">"]]]}]},{"name":"GatewayShardsInfo","description":"If the client uses sharding, information about how many shards to serve is received during the execution of client.start().\nTherefore, gateway needs such an option, it will override the existing settings and use them to connect.","meta":{"line":5,"file":"GatewayShardsInfo.ts","path":"gateway"},"props":[{"name":"shards","description":"Gateway shards ids to serve","optional":false,"type":[[["Array","<"],["number",">"]]]},{"name":"totalShards","description":"The number of shards the client has","optional":false,"type":[[["number"]]]}]},{"name":"Provider","description":"Base interface for all providers","meta":{"line":2,"file":"Provider.ts","path":"."},"props":[{"name":"init","description":"The init() function exists to tell the provider when the client connects to Discord.\nIf the provider started incorrectly, it should throw an error and reject the promise.","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["Promise","<"],["unknown",">"]]]}]},{"name":"RawAttachment","meta":{"line":1,"file":"RawAttachment.ts","path":"rest"},"props":[{"name":"data","description":"Attachment binary data","optional":false,"type":[[["ArrayBuffer"," | "],["Buffer"]]]},{"name":"name","description":"Attachment filename","optional":false,"type":[[["string"]]]}]},{"name":"RestFailedResponse","description":"Rest provider must return this when request execution failed.","meta":{"line":4,"file":"RestFailedResponse.ts","path":"rest"},"props":[{"name":"headers","description":"Response headers","optional":false,"type":[[["any"]]]},{"name":"latency","description":"The delay between sending the request and the first bit of the response","optional":false,"type":[[["number"]]]},{"name":"result","optional":false,"type":[[["any"]]]},{"name":"statusCode","description":"Response status code or -1 to indicate an internal error of the provider","optional":false,"type":[[["number"]]]},{"name":"success","description":"Whether request executed successfully or not","optional":false,"type":[[["false"]]]}]},{"name":"RestProvider","description":"Represents a rest provider. Custom rest providers must implement it.\n**Must not throw any errors**. Use RestFailedResponse instead.\n\nOptionally can handle rate limits. Built-in rate limits handling can be disabled in the rest options.","see":["https://github.com/Discordoo/discordoo/blob/develop/src/rest/DefaultRestProvider.ts"],"deprecated":false,"meta":{"line":15,"file":"RestProvider.ts","path":"rest"},"props":[{"name":"init","description":"The init() function exists to tell the provider when the client connects to Discord.\nIf the provider started incorrectly, it should throw an error and reject the promise.","optional":false,"type":[[["(..."],["args",": "],["unknown","[]) => "],["Promise","<"],["unknown",">"]]]},{"name":"request","description":"Perform a request","optional":false,"type":[[["("],["data",": "],["RestRequestData",", "],["options",": "],["RestRequestOptions",") => "],["RestFinishedResponse","<"],["T",">"]]]}]},{"name":"RestRequestData","description":"Data for the rest request","meta":{"line":5,"file":"RestRequestData.ts","path":"rest"},"props":[{"name":"attachments","description":"Files to attach (empty array if 0)","optional":false,"type":[[["Array","<"],["RawAttachment",">"]]]},{"name":"body","description":"Request body","optional":true,"type":[[["undefined"," | "],["Record","<"],["any",", "],["any",">"]]]},{"name":"headers","description":"Request headers","optional":true,"type":[[["undefined"," | "],["Record","<"],["string",", "],["any",">"]]]},{"name":"method","description":"GET, POST, etc.","optional":false,"type":[[["RestRequestMethods"]]]},{"name":"path","description":"Url path: https://www.youtube.com/ **watch?v=g0WmiI2QUw0**","optional":false,"type":[[["string"]]]}]},{"name":"RestRequestOptions","description":"Options for the rest request","meta":{"line":4,"file":"RestRequestOptions.ts","path":"rest"},"props":[{"name":"auth","description":"Auth to use for this request","optional":true,"type":[[["undefined"," | "],["AuthLike"]]]},{"name":"reason","description":"Reason for X-Audit-Log-Reason header","optional":true,"type":[[["undefined"," | "],["string"]]]},{"name":"useAuth","description":"Whether use any auth for request or not","optional":true,"type":[[["undefined"," | "],["boolean"]]]}]},{"name":"RestResponse","description":"Base for all rest provider responses","meta":{"line":2,"file":"RestResponse.ts","path":"rest"},"props":[{"name":"headers","description":"Response headers","optional":false,"type":[[["any"]]]},{"name":"latency","description":"The delay between sending the request and the first bit of the response","optional":false,"type":[[["number"]]]},{"name":"statusCode","description":"Response status code or -1 to indicate an internal error of the provider","optional":false,"type":[[["number"]]]},{"name":"success","description":"Whether request executed successfully or not","optional":false,"type":[[["boolean"]]]}]},{"name":"RestSuccessfulResponse","description":"Rest provider must return this when request executed successfully.","meta":{"line":4,"file":"RestSuccessfulResponse.ts","path":"rest"},"props":[{"name":"headers","description":"Response headers","optional":false,"type":[[["any"]]]},{"name":"latency","description":"The delay between sending the request and the first bit of the response","optional":false,"type":[[["number"]]]},{"name":"result","description":"Request result (json body)","optional":false,"type":[[["Body"]]]},{"name":"statusCode","description":"Response status code or -1 to indicate an internal error of the provider","optional":false,"type":[[["number"]]]},{"name":"success","description":"Whether request executed successfully or not","optional":false,"type":[[["true"]]]}]}],"types":[{"name":"AuthLike","type":[[["`"],["Bot"," "],["string","` | `"],["Bearer"," "],["string","`"]]],"meta":{"line":1,"file":"AuthLike.ts","path":"rest"}},{"name":"CacheStorageKey","description":"Cache storages have their own names, called CacheStorageKey.\nThe name \"global\" means that the operation occurs with all cache storages that are located in the specified keyspace.","type":[[["string"," | "],["'global'"]]],"meta":{"line":5,"file":"CacheStorageKey.ts","path":"cache"}},{"name":"GatewaySendPayloadLike","type":[[["{"],["\nd",": "],["any",","],["\nop",": "],["GatewayOpCodes\n","}"]]],"meta":{"line":3,"file":"GatewaySendPayloadLike.ts","path":"gateway"},"props":[{"name":"d","optional":true,"type":[[["undefined"," | "],["any"]]]},{"name":"op","optional":false,"type":[[["GatewayOpCodes"]]]}]},{"name":"RestFinishedResponse","description":"Just type alias because we don't like use ctrl+c and ctrl+v","type":[[["Promise","<"],["RestSuccessfulResponse","<"],["T","> | "],["RestFailedResponse",">"]]],"meta":{"line":7,"file":"RestFinishedResponse.ts","path":"rest"}}],"enums":[{"name":"GatewayOpCodes","meta":{"line":1,"file":"GatewayOpCodes.ts","path":"gateway"},"props":[{"name":"DISPATCH","type":[[["0"]]]},{"name":"HEARTBEAT","type":[[["1"]]]},{"name":"HEARTBEAT_ACK","type":[[["11"]]]},{"name":"HELLO","type":[[["10"]]]},{"name":"IDENTIFY","type":[[["2"]]]},{"name":"INVALID_SESSION","type":[[["9"]]]},{"name":"RECONNECT","type":[[["7"]]]},{"name":"REQUEST_GUILD_MEMBERS","type":[[["8"]]]},{"name":"RESUME","type":[[["6"]]]},{"name":"STATUS_UPDATE","type":[[["3"]]]},{"name":"VOICE_GUILD_PING","type":[[["5"]]]},{"name":"VOICE_STATE_UPDATE","type":[[["4"]]]}]},{"name":"RestRequestMethods","meta":{"line":1,"file":"RestRequestMethods.ts","path":"rest"},"props":[{"name":"DELETE","type":[[["\"DELETE\""]]]},{"name":"GET","type":[[["\"GET\""]]]},{"name":"PATCH","type":[[["\"PATCH\""]]]},{"name":"POST","type":[[["\"POST\""]]]},{"name":"PUT","type":[[["\"PUT\""]]]}]}],"functions":[],"variables":[]}],"time":1644240289304,"generator":"@discordoo/tapok 2.0.19"}